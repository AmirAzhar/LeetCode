// 1531. String Compression II
// https://leetcode.com/problems/string-compression-ii/description/

var getLengthOfOptimalCompression = function(s, k) {
    // Create a memo, where the key is ${i}_${lastChar}_${lastCharCount}_${k} and the value is the length for that key
    const memo = new Map()
    
    /** 
      * backtrack function visits every possible options (delete or keep) at every point of the string, to find the best possible solution
      *
      * @param i The index of the string to visit next
      * @param prevChar The last character that was visited in the string
      * @param prevCharCount A running count for the prevChar that was visited
      * @param k Number of replacements allowed
     */
    
    const backtrack = (i, prevChar, prevCharCount, k) => {

                // Base Case: Run out of replacements, assign its value to be a v high number to indicate that it is not the correct solution
        if (k < 0) return Number.MAX_SAFE_INTEGER

        // Base Case: End of string
        if (i >= s.length) return 0

        // Create a key based on the input
        const key = `${i}_${prevChar}_${prevCharCount}_${k}`

        // Check if value already exists in the memo
        if (key in memo) return memo[key]
        
        // Case 1: If the current char in the string is the same as the prev char, the count of the char increases and we move on to the next char in the string
        // We also need to consider the case when the prev count is 9 or 99 as the length will also increase when the number increases to 10 or 100
        // Also need to rmb that we are not adding 1 after single chars
        if (s[i] === prevChar){
            if (prevCharCount == 9 || prevCharCount == 99 || prevCharCount == 1) memo[key] =  1 + backtrack(i + 1, prevChar, prevCharCount + 1, k)
            else memo[key] =  backtrack(i + 1, prevChar, prevCharCount + 1, k)
        }
        else {
            // Case 2: If the chars are different, we have 2 choices - keep or delete the char. We have tho take the min of both these options.
            // if we keep, we must add 1 to the length of the key
            // if we delete, we do not need to increment the length, but the number of replacements, k, we can make, decreases.
            memo[key] = Math.min(
                1 + backtrack(i + 1, s[i], 1, k), 
                backtrack(i + 1, prevChar, prevCharCount, k - 1) 
            )
        }
        return memo[key]
    }
    return backtrack(0, '', 0, k)
};

// 1335. Minimum Difficulty of a Job Schedule
// https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/description/

var minDifficulty = function(jobDifficulty, d) {
  // Not enough jobs
  if (jobDifficulty.length < d) return -1;

  // DP memo where key is the start index and # days, value is max of curr job + min of all later days
  const memo = {};

  // We want to return the minimum total difficulty for each starting index
  // corresponding to each number of days left
  const dfs = (start, numDays) => {
      
      // Check if we have reached the end of all days
      if (numDays === d) return start === jobDifficulty.length ? 0 : Infinity
      
      // Create key and check in memo
      const key = `${start}-${numDays}`
      if (key in memo) return cache[key];
      
      // calculate the last index for this day's number
      // if we go beyond that index we will have more days than jobs
      const end = jobDifficulty.length - d + numDays;
      
      // result will hold the minimum total of all following days
      let result = Infinity;
      // max will hold the max for the current day
      let max = -Infinity
      
      // iterate through the jobs updating the max and searching the remainder
      // of jobs and days
      for (let i = start; i <= end; i++) {
          max = Math.max(max, jobDifficulty[i]);
          result = Math.min(result, max + dfs(i + 1, numDays + 1));
        }
          
    // save the result in the cach and return it;
    return memo[key] = result;
  }
  return dfs(0, 0);
}